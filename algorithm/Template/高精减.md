# 高精度减法

被减数 `a` 和减数 `b` ;

## 高精度减法实现

```
void highPrecisionSub(std::vector<int>& x, std::vector<int>& y,
                      std::vector<int>& res) {
  int temp = 0;
  for (int i = 0; i < x.size(); ++i) {
    temp = x[i];
    if (i < y.size()) {
      temp -= y[i];
    }

    if (temp < 0) {
      temp += 10;

      --x[i + 1];
    }

    res.push_back(temp);
  }

  // 处理前导 0
  while (res.size() > 1 && !res.back()) {
    res.pop_back();
  }
}
```

## 预处理

通过把字符串翻转，将数字的低位存入数组

```
for (int i = a.size() - 1; i >= 0; --i) {
  x.push_back(a[i] - '0');
}

for (int i = b.size() - 1; i >= 0; --i) {
  y.push_back(b[i] - '0');
}
```

始终保证 x 中保存的数大于 y 中保存的数，便于计算<br>
当发生交换时表示被减数小于减数，为结果添加 '-' 号

```
bool cmp(const std::vector<int>& x, const std::vector<int>& y) {
  if (x.size() != y.size()) {
    return x.size() > y.size();
  }

  for (int i = x.size() - 1; i >= 0; --i) {
    if (x[i] != y[i]) {
      return x[i] > y[i];
    }
  }

  return true;  // 当两个数字完全相同时，确保不会出现 '-0' 情况
}
```

```
if (!cmp(x, y)) {
  std::cout << "-";

  std::swap(x, y);
}
```