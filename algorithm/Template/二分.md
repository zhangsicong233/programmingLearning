# 二分查找

**最佳模板**

`n`为数据长度

**最大化查找(以 int 为例)**

寻找最后一个大于等于`target`的元素

```
int binarySearch(int target, int n) {
  int l = 0;
  int r = n + 1;

  while (l + 1 < r) {
    int mid = l + r >> 1;
    if (arr[mid] >= target) {
      l = mid;
    } else {
      r = mid;
    }
  }

  return l;
}
```

**最小化查找(以 int 为例)**

寻找第一个大于等于`target`的元素

```
int binarySearch(int target, int n) {
  int l = 0;
  int r = n + 1;

  while (l + 1 < r) {
    int mid = l + r >> 1;
    if (arr[mid] >= target) {
      r = mid;
    } else {
      l = mid;
    }
  }

  return r;
}
```